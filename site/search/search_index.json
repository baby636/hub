{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome To CertiK Foundation \u00b6 What is CertiK Chain \u00b6 The CertiK Chain is a public platform based on the CertiK Foundation\u2019s unique Formal Verification security system. On-chain smart contracts will contain cryptographic certificates as proof of verified security. Smart contracts may interact with each other and check for these machine-checkable proofs in order to gain assurances of security. Smart contracts that do not have these verified certificates may require higher fees to transact. Security will be prioritized from the bottom-up. On the base layer is the CertiK Virtual Machine (CVM) , which will undergo Formal Verification to certify the correctness of its implementation. The CertiK Chain will use a verified compiler that assures no bugs are introduced during the transformation of source code into the CVM bytecode. For universal ease-of-use, developers will be able to create smart contracts using the functional programming language, DeepSEA, which has been awarded grants from IBM and The Ethereum Foundation, for integration with Hyperledger Burrow and the Ethereum Virtual Machine (EVM) . With DeepSEA, your security is proven within the code itself, backed by a fully certified compiler. With this project, CertiK aims to build a blockchain infrastructure that can provide truly unrivaled end-to-end security. To achieve that, full nodes of CertiK Chain will run on CertiKOS, the world\u2019s first and only fully verified hypervisor / concurrent OS kernel, also developed by CertiK\u2019s co-founders. CertiKOS can work as a military-grade secure enclave and protect CertiK Chain nodes from hacker attacks. Why It Matters \u00b6 To form a safer blockchain ecosystem, security must be built from the ground up. Giving developers and users access to a scalable, intuitive, and safe product encourages long-term adoption, especially for large enterprises. By putting security at the forefront of its development, the CertiK Chain aims to mitigate the security vulnerabilities that have plagued the blockchain world, stifling innovation. In turn, the CertiK Chain will help provide individuals and enterprises with the confidence needed for broader adoption. With the CertiK Chain, we\u2019re proud to take the first step in creating a blockchain that can be trusted, built on, and improved for years to come. CertiK Chain is the key component in CertiK's vision of building end-to-end secure and trustworthy infrastructure for the blockchain world. Here is a brief introduction to the chain. The first version of CertiK Chain is the testnet, which will go through three stages: Closed Alpha Open Beta Full Testnet The overall goal of testnet is to define and implement a majority of the CertiK Chain features and build a strong CertiK Chain developer and user community by providing opportunities to contribute to the chain design and development, to evaluate the chain's main features, and to develop smart contracts and other usage scenarios around the chain. As testnet moves through its various stages, CertiK Foundation expects to provide ample opportunities for active members of the community to be rewarded for their contributions. Timeline \u00b6 Stage Expected Timeframe Closed Alpha 1.0 July 22 2019 \ud83d\ude80 Closed Alpha 2.0 November 04 2019 \ud83d\ude80 \u2615 [ CURRENT STAGE ] Open Beta 3.0 TBA \u231b ... TBA \u231b Full Testnet TBA \u231b Closed Alpha \u00b6 The very first stage of testnet is the closed alpha stage, which is the current stage. At the beginning of this stage, most chain features are either not fully tested, partially implemented, or even unimplemented. Hence for this stage we talk about \"what (mostly) works\" rather than \"what does not work\". During this stage, testnet backend and frontend are expected to receive a lot of updates, often causing the chain to be re-deployed from scratch. The validator set size will be small (e.g., no more than 20). The closed alpha stage will last until most testnet features are implemented and alpha-tested. Open Beta \u00b6 The second stage of testnet is the open beta stage. It starts when the closed alpha stage exits with most testnet features implemented and alpha-tested. For this stage we switch to talk about \"what is missing\" instead of \"what works\". During this stage, testnet backend and frontend are expected to receive constant updates, occasionally causing the chain to be re-deployed from scratch. The validator set size will be medium (e.g., no more than 50). The open beta stage will last until all testnet features are implemented and properly tested. Full Testnet \u00b6 The final full stage of testnet starts when the open beta stage exits with all testnet features properly tested. During this stage, testnet backend and frontend are exepcted to receive on-demand updates. Branching instead of re-deployment will be preferred when solving chain divergence. The validator set size will be large (e.g., no more than 100).","title":"What is CertiK Chain"},{"location":"#welcome-to-certik-foundation","text":"","title":"Welcome To CertiK Foundation"},{"location":"#what-is-certik-chain","text":"The CertiK Chain is a public platform based on the CertiK Foundation\u2019s unique Formal Verification security system. On-chain smart contracts will contain cryptographic certificates as proof of verified security. Smart contracts may interact with each other and check for these machine-checkable proofs in order to gain assurances of security. Smart contracts that do not have these verified certificates may require higher fees to transact. Security will be prioritized from the bottom-up. On the base layer is the CertiK Virtual Machine (CVM) , which will undergo Formal Verification to certify the correctness of its implementation. The CertiK Chain will use a verified compiler that assures no bugs are introduced during the transformation of source code into the CVM bytecode. For universal ease-of-use, developers will be able to create smart contracts using the functional programming language, DeepSEA, which has been awarded grants from IBM and The Ethereum Foundation, for integration with Hyperledger Burrow and the Ethereum Virtual Machine (EVM) . With DeepSEA, your security is proven within the code itself, backed by a fully certified compiler. With this project, CertiK aims to build a blockchain infrastructure that can provide truly unrivaled end-to-end security. To achieve that, full nodes of CertiK Chain will run on CertiKOS, the world\u2019s first and only fully verified hypervisor / concurrent OS kernel, also developed by CertiK\u2019s co-founders. CertiKOS can work as a military-grade secure enclave and protect CertiK Chain nodes from hacker attacks.","title":"What is CertiK Chain"},{"location":"#why-it-matters","text":"To form a safer blockchain ecosystem, security must be built from the ground up. Giving developers and users access to a scalable, intuitive, and safe product encourages long-term adoption, especially for large enterprises. By putting security at the forefront of its development, the CertiK Chain aims to mitigate the security vulnerabilities that have plagued the blockchain world, stifling innovation. In turn, the CertiK Chain will help provide individuals and enterprises with the confidence needed for broader adoption. With the CertiK Chain, we\u2019re proud to take the first step in creating a blockchain that can be trusted, built on, and improved for years to come. CertiK Chain is the key component in CertiK's vision of building end-to-end secure and trustworthy infrastructure for the blockchain world. Here is a brief introduction to the chain. The first version of CertiK Chain is the testnet, which will go through three stages: Closed Alpha Open Beta Full Testnet The overall goal of testnet is to define and implement a majority of the CertiK Chain features and build a strong CertiK Chain developer and user community by providing opportunities to contribute to the chain design and development, to evaluate the chain's main features, and to develop smart contracts and other usage scenarios around the chain. As testnet moves through its various stages, CertiK Foundation expects to provide ample opportunities for active members of the community to be rewarded for their contributions.","title":"Why It Matters"},{"location":"#timeline","text":"Stage Expected Timeframe Closed Alpha 1.0 July 22 2019 \ud83d\ude80 Closed Alpha 2.0 November 04 2019 \ud83d\ude80 \u2615 [ CURRENT STAGE ] Open Beta 3.0 TBA \u231b ... TBA \u231b Full Testnet TBA \u231b","title":"Timeline"},{"location":"#closed-alpha","text":"The very first stage of testnet is the closed alpha stage, which is the current stage. At the beginning of this stage, most chain features are either not fully tested, partially implemented, or even unimplemented. Hence for this stage we talk about \"what (mostly) works\" rather than \"what does not work\". During this stage, testnet backend and frontend are expected to receive a lot of updates, often causing the chain to be re-deployed from scratch. The validator set size will be small (e.g., no more than 20). The closed alpha stage will last until most testnet features are implemented and alpha-tested.","title":"Closed Alpha"},{"location":"#open-beta","text":"The second stage of testnet is the open beta stage. It starts when the closed alpha stage exits with most testnet features implemented and alpha-tested. For this stage we switch to talk about \"what is missing\" instead of \"what works\". During this stage, testnet backend and frontend are expected to receive constant updates, occasionally causing the chain to be re-deployed from scratch. The validator set size will be medium (e.g., no more than 50). The open beta stage will last until all testnet features are implemented and properly tested.","title":"Open Beta"},{"location":"#full-testnet","text":"The final full stage of testnet starts when the open beta stage exits with all testnet features properly tested. During this stage, testnet backend and frontend are exepcted to receive on-demand updates. Branching instead of re-deployment will be preferred when solving chain divergence. The validator set size will be large (e.g., no more than 100).","title":"Full Testnet"},{"location":"getting-started/","text":"What is certik? \u00b6 certik is the name for the Cosmos Hub. It provides two entrances to interact with CertiK Chain: certikd : The daemon for running a full-node of the gaia application. certikcli : The command-line interface that interacting with the certik full-node.","title":"Getting started"},{"location":"getting-started/#what-is-certik","text":"certik is the name for the Cosmos Hub. It provides two entrances to interact with CertiK Chain: certikd : The daemon for running a full-node of the gaia application. certikcli : The command-line interface that interacting with the certik full-node.","title":"What is certik?"},{"location":"installation/","text":"Installation \u00b6 Setup Server \u00b6 Server environment Ubuntu 18.04 Installing Go \u00b6 In this step, you\u2019ll install Go by downloading the go installer, in this tutorial will use the version go 1.13.3 from the official Go downloads page. Before downloading Go, make sure that you are in the home (~) directory: cd ~ Use curl to retrieve the tarball URL that you copied from the official Go downloads page: curl -O https://dl.google.com/go/go1.13.3.linux-amd64.tar.gz Next, extract the downloaded archive and install it to the desired location on the system. It\u2019s considered best practice to keep it under /usr/local : sudo tar -xzf go1.13.3.linux-amd64.tar.gz -C /usr/local Notes Although /usr/local/go is the officially-recommended location, some users may prefer or require different paths. Configuration \u00b6 Prior to Go 1.8, it was required to set a local environment variable called $GOPATH . $GOPATH told the compiler where to find imported third party source code, as well as any local source code you had written. While it is no longer explicitly required, it is still considered a good practice as many third party tools still depend on this variable being set. You can set your $GOPATH by adding the global variables to your ~/.profile. You may want to add this into .zshrc or .bashrc file as per your shell configuration. First, open ~/.profile or ~/.bashrc with nano or your preferred text editor: nano ~/.profile Now you need to setup Go language environment variables for your project. Commonly you need to set 3 environment variables as GOROOT, GOPATH and PATH. GOROOT is the location where Go package is installed on your system. GOPATH is the location of your work directory. For example my project directory is ~/Projects/Proj1 . Now you can export the setting into the ~/.profile or ~/.bashrc # export GOPATH echo \"export GOPATH= $HOME /go\" >> ~/.bashrc # set PATH so it includes user's private bin directories echo \"export PATH=\\\" $PATH : $GOPATH /bin:/usr/local/go/bin\\\"\" >> ~/.bashrc To update your shell, issue the following command to load the global variables: . ~/.bashrc You can verify your $PATH is updated by using the echo command and inspecting the output: echo $PATH Finally, check your go version: go version Also Verify all configured environment variables using following command. go env Binary \u00b6 The latest chain node binary and CLI tool binary can be downloaded from: v0.4-alpha Latest-Release Notes certikd : The daemon for running a full-node of the certik application. certikcli : The command-line interface that interacting with the certik full-node.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#setup-server","text":"Server environment Ubuntu 18.04","title":"Setup Server"},{"location":"installation/#installing-go","text":"In this step, you\u2019ll install Go by downloading the go installer, in this tutorial will use the version go 1.13.3 from the official Go downloads page. Before downloading Go, make sure that you are in the home (~) directory: cd ~ Use curl to retrieve the tarball URL that you copied from the official Go downloads page: curl -O https://dl.google.com/go/go1.13.3.linux-amd64.tar.gz Next, extract the downloaded archive and install it to the desired location on the system. It\u2019s considered best practice to keep it under /usr/local : sudo tar -xzf go1.13.3.linux-amd64.tar.gz -C /usr/local Notes Although /usr/local/go is the officially-recommended location, some users may prefer or require different paths.","title":"Installing Go"},{"location":"installation/#configuration","text":"Prior to Go 1.8, it was required to set a local environment variable called $GOPATH . $GOPATH told the compiler where to find imported third party source code, as well as any local source code you had written. While it is no longer explicitly required, it is still considered a good practice as many third party tools still depend on this variable being set. You can set your $GOPATH by adding the global variables to your ~/.profile. You may want to add this into .zshrc or .bashrc file as per your shell configuration. First, open ~/.profile or ~/.bashrc with nano or your preferred text editor: nano ~/.profile Now you need to setup Go language environment variables for your project. Commonly you need to set 3 environment variables as GOROOT, GOPATH and PATH. GOROOT is the location where Go package is installed on your system. GOPATH is the location of your work directory. For example my project directory is ~/Projects/Proj1 . Now you can export the setting into the ~/.profile or ~/.bashrc # export GOPATH echo \"export GOPATH= $HOME /go\" >> ~/.bashrc # set PATH so it includes user's private bin directories echo \"export PATH=\\\" $PATH : $GOPATH /bin:/usr/local/go/bin\\\"\" >> ~/.bashrc To update your shell, issue the following command to load the global variables: . ~/.bashrc You can verify your $PATH is updated by using the echo command and inspecting the output: echo $PATH Finally, check your go version: go version Also Verify all configured environment variables using following command. go env","title":"Configuration"},{"location":"installation/#binary","text":"The latest chain node binary and CLI tool binary can be downloaded from: v0.4-alpha Latest-Release Notes certikd : The daemon for running a full-node of the certik application. certikcli : The command-line interface that interacting with the certik full-node.","title":"Binary"},{"location":"participate/","text":"How to Participate \u00b6 The CertiK Chain Explorer is public accessible and can be used to query on various status of the chain on the web. To do transactions on the chain, all alpha testers need to apply via the CertiK Foundation website . Currently, chain transactions as well as chain account creation can only be performed via the CLI tool or CLI-based RESTful server. In the near future web wallet will be supported to allow using the chain without the CLI tool. The latest chain node binary and CLI tool binary can be downloaded from https://github.com/certikfoundation/chain/releases/ . Run A Full Node \u00b6 During the closed alpha stage, full node addresses for the CLI tool to connect to can be obtained from the mailing list. It is also possible to run your own full nodes and connect the CLI tool to them. In next section you will be shown how to convert your full nodes into validator nodes. With certikd one can run full nodes of the CertiK Chain. Its configuration needs to be properly initialized. certikd init Saved genesis to /home/ubuntu/.certikd/config/genesis.json { \"moniker\" : \"CTK-Validator\" , \"chain_id\" : \"test-chain-2PTdES\" , \"node_id\" : \"cc5a0cc12a1afe945bdc9aa2a6ac16f96fb15e1a\" , \"gentxs_dir\" : \"\" , \"app_message\" : { \"accounts\" : null , \"auth\" : { \"collected_fees\" : [], \"params\" : { \"max_memo_characters\" : \"256\" , \"tx_sig_limit\" : \"7\" , \"tx_size_cost_per_byte\" : \"10\" , \"sig_verify_cost_ed25519\" : \"590\" , \"sig_verify_cost_secp256k1\" : \"1000\" } }, \"bank\" : { \"send_enabled\" : true }, \"staking\" : { \"pool\" : { \"not_bonded_tokens\" : \"0\" , \"bonded_tokens\" : \"0\" }, \"params\" : { \"unbonding_time\" : \"259200000000000\" , \"max_validators\" : 100 , \"max_entries\" : 7 , \"bond_denom\" : \"uckt\" }, \"last_total_power\" : \"0\" , \"last_validator_powers\" : null , \"validators\" : null , \"delegations\" : null , \"unbonding_delegations\" : null , \"redelegations\" : null , \"exported\" : false }, \"distr\" : { \"fee_pool\" : { \"community_pool\" : [] }, \"community_tax\" : \"0.020000000000000000\" , \"base_proposer_reward\" : \"0.010000000000000000\" , \"bonus_proposer_reward\" : \"0.040000000000000000\" , \"withdraw_addr_enabled\" : true , \"delegator_withdraw_infos\" : [], \"previous_proposer\" : \"\" , \"outstanding_rewards\" : [], \"validator_accumulated_commissions\" : [], \"validator_historical_rewards\" : [], \"validator_current_rewards\" : [], \"delegator_starting_infos\" : [], \"validator_slash_events\" : [] }, \"slashing\" : { \"params\" : { \"max_evidence_age\" : \"120000000000\" , \"signed_blocks_window\" : \"100\" , \"min_signed_per_window\" : \"0.500000000000000000\" , \"downtime_jail_duration\" : \"600000000000\" , \"slash_fraction_double_sign\" : \"0.050000000000000000\" , \"slash_fraction_downtime\" : \"0.010000000000000000\" }, \"signing_infos\" : {}, \"missed_blocks\" : {} }, \"gentxs\" : null } } Modify the ~/.certikd/config/config.toml adding following field: # Update the moniker fields sed \"s/moniker = .* $ /moniker = \\\"<YOUR-CUSTOM-NAME>\\\"/\" ~/.certikd/config/config.toml # Update the persistent_peers fields sed \"s/persistent_peers *=.*/persistent_peers = \\\"9154957b5246d6c913cdd82dade7db8cf194623b@18.236.198.102:26656,ea7baf3d58b698c0d060c6c13a6832b0ecf7d509@34.219.251.115:26656\\\"/g\" ~/.certikd/config/config.toml Then copy the testnet genesis JSOn file to the node configuration directory. cp <PATH-TO-Binary>/chain-0.4-alpha/genesis.json ~/.certikd/config Create Test Accounts \u00b6 Make sure you have configured the CLI tool properly as described in the above section. To use the CertiK Chain and do transactions on the chain, one need to first create a chain account and then populate it with test tokens. First, create an account address and public / private key pair on your computer. In interactions with the chain, public address and key are used frequently. The private key is stored in your local computer and is needed to sign your transaction before submitting. $ certikcli keys add <account name> Enter a passphrase to encrypt your key to disk: Repeat the passphrase: NAME: TYPE: ADDRESS: PUBKEY: <account name> local <account address> <account public key> **Important** write this mnemonic phrase in a safe place. It is the only way to recover your account if you ever forget your password. ... Then, go to http://explorer.certik.foundation/faucet , submit your test account's address. The account will receive some amount of CKT and CKG tokens for testing purpose. Please do not abuse the faucet as there are only limited number of tokens available for testnet. You can create multiple accounts for testing purpose. Please note that the testnet can be restarted often during the alpha testing stage, so you may need to re-create account / re-apply for test tokens on each testnet restart. Convert a Full Node into Validator (important) \u00b6 As CertiK Chain is designed with focus on ultimate blockchain security, one of the security requirements is that all validator nodes must be certified by either CertiK or other approved certifiers . The actual range of validator node certification is not fully defined during the closed alpha stage, but in general CertiK Chain validator nodes are expected to be powerful with good connectivity, use latest official chain node software releases, and eventually run on secure systems software such as CertiKOS (this is unavailable during closed alpha). After creating the full node and completely loading chain history onto it, the current way to get it \"certified\" to be eligible to for validator purpose is the following. First, run below commend on your node instance for obtaining the tendermint pubkey. certikd tendermint show-validator Then send the pubkey to chain@certik.org with title \"request to certify validator node\" and optionally your reasoning on why this node should be approved to become a validator node (typically in terms of capacity, connectivity, maintenance, and security). Within 24 hours, CertiK will get back to you with either \"certified\" or \"rejected\" message. Once receiving the \"certified\" message, you can proceed to convert your full node to become a validator node following the instruction on https://certikfoundation.github.io . Notes It is important to note that the current certification process and requirement is likely very different from the future validator node certification. So being certified today does not guarantee the same node will be certified for future versions of testnet and mainnet.","title":"Join the Testnet"},{"location":"participate/#how-to-participate","text":"The CertiK Chain Explorer is public accessible and can be used to query on various status of the chain on the web. To do transactions on the chain, all alpha testers need to apply via the CertiK Foundation website . Currently, chain transactions as well as chain account creation can only be performed via the CLI tool or CLI-based RESTful server. In the near future web wallet will be supported to allow using the chain without the CLI tool. The latest chain node binary and CLI tool binary can be downloaded from https://github.com/certikfoundation/chain/releases/ .","title":"How to Participate"},{"location":"participate/#run-a-full-node","text":"During the closed alpha stage, full node addresses for the CLI tool to connect to can be obtained from the mailing list. It is also possible to run your own full nodes and connect the CLI tool to them. In next section you will be shown how to convert your full nodes into validator nodes. With certikd one can run full nodes of the CertiK Chain. Its configuration needs to be properly initialized. certikd init Saved genesis to /home/ubuntu/.certikd/config/genesis.json { \"moniker\" : \"CTK-Validator\" , \"chain_id\" : \"test-chain-2PTdES\" , \"node_id\" : \"cc5a0cc12a1afe945bdc9aa2a6ac16f96fb15e1a\" , \"gentxs_dir\" : \"\" , \"app_message\" : { \"accounts\" : null , \"auth\" : { \"collected_fees\" : [], \"params\" : { \"max_memo_characters\" : \"256\" , \"tx_sig_limit\" : \"7\" , \"tx_size_cost_per_byte\" : \"10\" , \"sig_verify_cost_ed25519\" : \"590\" , \"sig_verify_cost_secp256k1\" : \"1000\" } }, \"bank\" : { \"send_enabled\" : true }, \"staking\" : { \"pool\" : { \"not_bonded_tokens\" : \"0\" , \"bonded_tokens\" : \"0\" }, \"params\" : { \"unbonding_time\" : \"259200000000000\" , \"max_validators\" : 100 , \"max_entries\" : 7 , \"bond_denom\" : \"uckt\" }, \"last_total_power\" : \"0\" , \"last_validator_powers\" : null , \"validators\" : null , \"delegations\" : null , \"unbonding_delegations\" : null , \"redelegations\" : null , \"exported\" : false }, \"distr\" : { \"fee_pool\" : { \"community_pool\" : [] }, \"community_tax\" : \"0.020000000000000000\" , \"base_proposer_reward\" : \"0.010000000000000000\" , \"bonus_proposer_reward\" : \"0.040000000000000000\" , \"withdraw_addr_enabled\" : true , \"delegator_withdraw_infos\" : [], \"previous_proposer\" : \"\" , \"outstanding_rewards\" : [], \"validator_accumulated_commissions\" : [], \"validator_historical_rewards\" : [], \"validator_current_rewards\" : [], \"delegator_starting_infos\" : [], \"validator_slash_events\" : [] }, \"slashing\" : { \"params\" : { \"max_evidence_age\" : \"120000000000\" , \"signed_blocks_window\" : \"100\" , \"min_signed_per_window\" : \"0.500000000000000000\" , \"downtime_jail_duration\" : \"600000000000\" , \"slash_fraction_double_sign\" : \"0.050000000000000000\" , \"slash_fraction_downtime\" : \"0.010000000000000000\" }, \"signing_infos\" : {}, \"missed_blocks\" : {} }, \"gentxs\" : null } } Modify the ~/.certikd/config/config.toml adding following field: # Update the moniker fields sed \"s/moniker = .* $ /moniker = \\\"<YOUR-CUSTOM-NAME>\\\"/\" ~/.certikd/config/config.toml # Update the persistent_peers fields sed \"s/persistent_peers *=.*/persistent_peers = \\\"9154957b5246d6c913cdd82dade7db8cf194623b@18.236.198.102:26656,ea7baf3d58b698c0d060c6c13a6832b0ecf7d509@34.219.251.115:26656\\\"/g\" ~/.certikd/config/config.toml Then copy the testnet genesis JSOn file to the node configuration directory. cp <PATH-TO-Binary>/chain-0.4-alpha/genesis.json ~/.certikd/config","title":"Run A Full Node"},{"location":"participate/#create-test-accounts","text":"Make sure you have configured the CLI tool properly as described in the above section. To use the CertiK Chain and do transactions on the chain, one need to first create a chain account and then populate it with test tokens. First, create an account address and public / private key pair on your computer. In interactions with the chain, public address and key are used frequently. The private key is stored in your local computer and is needed to sign your transaction before submitting. $ certikcli keys add <account name> Enter a passphrase to encrypt your key to disk: Repeat the passphrase: NAME: TYPE: ADDRESS: PUBKEY: <account name> local <account address> <account public key> **Important** write this mnemonic phrase in a safe place. It is the only way to recover your account if you ever forget your password. ... Then, go to http://explorer.certik.foundation/faucet , submit your test account's address. The account will receive some amount of CKT and CKG tokens for testing purpose. Please do not abuse the faucet as there are only limited number of tokens available for testnet. You can create multiple accounts for testing purpose. Please note that the testnet can be restarted often during the alpha testing stage, so you may need to re-create account / re-apply for test tokens on each testnet restart.","title":"Create Test Accounts"},{"location":"participate/#convert-a-full-node-into-validator-important","text":"As CertiK Chain is designed with focus on ultimate blockchain security, one of the security requirements is that all validator nodes must be certified by either CertiK or other approved certifiers . The actual range of validator node certification is not fully defined during the closed alpha stage, but in general CertiK Chain validator nodes are expected to be powerful with good connectivity, use latest official chain node software releases, and eventually run on secure systems software such as CertiKOS (this is unavailable during closed alpha). After creating the full node and completely loading chain history onto it, the current way to get it \"certified\" to be eligible to for validator purpose is the following. First, run below commend on your node instance for obtaining the tendermint pubkey. certikd tendermint show-validator Then send the pubkey to chain@certik.org with title \"request to certify validator node\" and optionally your reasoning on why this node should be approved to become a validator node (typically in terms of capacity, connectivity, maintenance, and security). Within 24 hours, CertiK will get back to you with either \"certified\" or \"rejected\" message. Once receiving the \"certified\" message, you can proceed to convert your full node to become a validator node following the instruction on https://certikfoundation.github.io . Notes It is important to note that the current certification process and requirement is likely very different from the future validator node certification. So being certified today does not guarantee the same node will be certified for future versions of testnet and mainnet.","title":"Convert a Full Node into Validator (important)"}]}